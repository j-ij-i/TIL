# DynamicProgramming

피보나치 수열을 구하는 재귀 함수
```
fibo(n) : 
IF n < 2 : Return n; // n항을 구하는 메소드
ELSE : RETUN fibo(n-1) + fibo(n-2);
```
하지만, 재귀 함수를 사용할 경우 엄청난 중복 호출이 발생한다.
```
(fibo(6 ) (fibo(5)(fibo(4)(...) + fibo(3)(...)) + fibo(4)(fibo(3)(...) + fibo(2)(...) )) + fibo(5)(fibo(4)(...)  + fibo(3)(...) )
```

재귀함수의 중복을 최소한으로 줄이는 방법으로 fibo(n)의 값을 계산하자마자 저장하면, 실행시간 O(n) 가능 👉 **Memorization 사용**

### **Memorization 알고리즘**

- memo를 위한 배열을 할당하고 모두 0으로 초기화한다.
- memo[0]을 0으로 memo[1]는 1로 초기화 한다. ⇒ memo를 사용하기 위해서는 이미 memo 배열이 계산 되었는지 판단할 수 있어야 한다. 👉 초기화 필요

## 동적 계획법(Dynamic Programming)
**동적 계획법(Dynamic Programming)** 은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘이다. ex) 최대, 최소문제, 경우의수 문제

- 먼저 작은 부분 문제들의 해를 구하고, 이들을 이용해 큰 크기의 부분 문제를 해결하여 최종적으로 원래 주어진 문제를 해결하는 알고리즘.

### 최적 부문문제 구조(Optimal substructure)

- 동적 계획법을 최적화에 대한 어떤 문제에든 적용할 수 었다. 주어진 문제가 최적화의 원칙을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.
- 최적화의 원칙 : 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적이여야 한다.
- 작은 문제의 최적해를 통해 큰 문제의 최적해를 구하기 때문에 작은 문제의 최적해들로 구성되지 못하면 동적 계획법을 작성할 수 없다.
- 최적의 원칙이 적용되지 않는 예 ) 최장경로 문제

### 중복 부분문제 구조(Overlapping subproblems)

- DP는 큰 문제를 이루는 작은문제들을 먼저 해결하고, 작은 문제들의 최적 해를 이용하여 순환적으로 큰 문제를 해결한다.
- DP는 문제의 순환적인 성질때문에 이전에 계산되었던 작은 문제의 해들을 어떤 저장공간(table)에 저장하고, 저장된 해들을 다시 필요할때마다 재계산하지않고 table 참조를 통해 중복된 계산을 피한다.

### 분할 정복

- 연관 없는 부분 문제로 분할한다
- 부분문제를 재귀적으로 해결한다.
- 부분문제의 해를 결합한다.
- ex) 병합 정렬, 퀵 정렬

### 3단계 DP 적용 접근 방법
1. 최적해 구조의 특성을 파악하라.      
2. 최적해의 값을 재귀적으로 정의하라.
3. 상향식 방법으로 최적해의 값을 계산하라. 
