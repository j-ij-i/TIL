# 04. 변수

## 4.1 **무엇일까?**

- 데이터를 입력받아 처리하고 출력하는 과정속에서 데이터를 관리하기 위한 핵심 개념

### `10 + 20` 이 해석되는 순서

1. 자바스크립트 엔진이 10, 20, + 기호의 의미를 알고 있어야 하며 해석한다.
2. 연산을 수행하기 위해 피연산자(좌변)을 기억한다.
3. 컴퓨터의 CPU를 통해 연산하고 메모리를 통해 데이터를 기억한다.
4. 메모리는 셀의 집합체이며 메모리 셀 하나의 크기가 1바이트이다. (컴퓨터는 1바이트 단위로 저장하고 읽어들인다.)
5. 각 셀은 고유의 메모리 주소를 가지며 모든 데이터를 2진수로 처리한다.

- 변수는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**을 말한다.
- **값의 위치를 가리키는 상징적인 이름 ⇒ 변수 이름(변수 명)**
- 변수에 저장된 값 ⇒ **변수 값**
- 변수에 값을 저장하는 것 ⇒ **할당(대입, 저장)**
- 변수에 저장된 값을 읽어들이는 것 ⇒ **참조**

## 4.2 식별자

- 변수의 이름을 식별자라고도 함. (식별자: 어떤 값을 구별해서 식별할 수 있는 고유한 이름)
- 식별자는 값이 아니라 메모리 주소를 기억.
- 변수, 함수, 클래스 등 이름 모두 식별자.

## 4.3 변수 선언

- 변수를 선언할 때 var, let, const 키워드를 반드시 사용한다.
- 변수를 선언 후 아직 할당하지 않았다면 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.
- 자바스크립트 엔진의 변수선언
  1. **선언 단계** : 변수 이름을 등록해서 자바스클비트 엔진에 변수를 알림.
  2. **초기화 단계** : 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화.
- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.
  - **실행 컨텍스트(execution context)**란 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위한 환경을 제공하고 결과를 관리하는 영역. 실행 컨택스트로 식별자와 스코프를 관리
  - 변수와 변수 값은 key와 value 형식인 객체로 등록되어 관리된다.
- 선언하지 않은 식별자에 접근하면 ReferenceError가 발생한다.(자바스크립트 엔진에 등록된 식별자를 찾을 수 없을 때 발생)

> **ES5 VS ES6**

- ES5의 var 키워드의 대표적인 단점: 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다. 의도치 않게 전역변수로 선언 된다.
- ES6에서는 var 키워드의 단점을 보완하여 let과 const가 등장하였다.
- let과 const가 도입되어도 var 키워드가 폐기되지 않았고 ES6에도 여전히 var키워드를 사용할 수 있다.
- ES6는 ES5의 상위 집합이므로 ES5도 작동한다. 따라서 ES5도 잘 알아둘 필요가 있다.

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score); // undefined
var score; // 변수 선언문
```

- 변수 선언은 한줄씩 순차적으로 실행되는 시점인 런타임이 아닌 그 이전 단계에서 먼저 선언된다.
- 자바스크립트 엔진은 변수선언을 포함한 모든 선언문을 소스코드에서 먼저 찾아내 먼저 실행한다.
- 평가과정이 끝나면 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것을 **변수 호이스팅**이라고 한다.
  - var, let, const, function, function\*, class 등 식별자 키워드 들이 모두 호이스팅 된다.

## 4.5 값의 할당

- 오른쪽에서 왼쪽으로 할당.
- 선언이 먼저고 다음으로 값의 할당됨.
- **변수 선언은 런타임 이전에 실행되지만 할당은 순차적으로 런타임에 실행된다.**

```jsx
console.log(score); // undefiend

var score;
score = 80;

console.log(score); // 80
```

## 4.6 값의 재할당

- 재할당 : 이미 할당되어 있는 변수에 새로운 값을 또다시 할당
- 변수가 값을 재할당 할 수 없다면 변수가 아니라 상수이다.
- const 키워드는 재할당이 금지된다. 따라서 const로 상수를 표현할 수 있다. but, 상수만을 위해서 사용하지 않는다.
- 재할당 되면서 그 이전 값들은 더이상 아무도 사용하지 않으므로 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 하지만 언제 해제 될지는 예측할 수 없다.

**가비지 콜렉터(garbage collector)**

- 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하는 기능을 말한다.
- 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.

ES2021에 등장 =>**`[WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)`**

- 참조 카운트를 처음부터 없는 상태로 줌.
- `[WeakRef.prototype.deref()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref)`
- deref()로 직접 접근해서 회수되었는지 아닌지 확인할 수 있음
- 사용중에 가비지 콜렉터가 메모리를 회수할 수 있음.

## 4.7 식별자 네이밍 규칙

- 특수 문자를 제외한 문자, 숫자, 언더 스코어, 달러 기호를 포함할 수 있다.
- 문자, 언더스코어, 달러기호로 시작해야한다. 숫자 허용 X
- 예약어는 식별자 사용 X
- ES5부터 식별자에 유니코드 문자를 허용하였지만, 알파벳 외의 유니코드 문자는 권장하지 않는다.
- 대소문자를 구분하여 변수가 선언된다.
- 의미 표현을 명확하게 해야 코드의 가독성을 높일 수 있다.

**네이밍 컨벤션**

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
// 잘안씀
```

- 일반적으로 변수나 함수의 이름에서는 카멜케이스를 사용한다,
- 생성자 함수, 클래스 이름에서는 파스칼 케이스를 사용한다.
- ECMAScript에서도 카멜케이스와 파스칼케이스를 사용한다. ⇒ 카멜, 파스칼 케이스 권장
